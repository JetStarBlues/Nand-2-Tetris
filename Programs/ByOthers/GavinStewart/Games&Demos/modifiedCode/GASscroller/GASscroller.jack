/**
 * Implements GASscroller app.
 
  Horizontal text scroller. Uses multiple buffers to hold the scroll text
  at progressively shifted offsets. Only the last two words of the buffer
  need be updated per cycle (for each row). The buffers are ring buffers, so 
  previously calculated offsets are re-used. This method is very efficient! 
 
            <---------- Visible Area ---------> <-- word -->          
           |___________ ___________ ___________|___________
           |_____A_____|_____B_____|_____C_____|_____D_____| <- Buffer 0
        :  |__A_____:__|__B_____:__|__C_____:__|__D_____:__| <- Buffer 1
     :     A_____:_____B_____:_____C_____:_____D_____:_____| <- Buffer 2
  :     A  |__:_____B__|__:_____C__|__:_____D__|__:________| <- Buffer 3
           |_____B_____|_____C_____|_____D_____|_____E_____| <- Buffer 0
           |                                   |
           
  Diagram shows single row from four progressively shifted buffers. Drawing
  the buffers sequentially makes the content of each word appear to scroll
  across screen. After the last buffer is drawn, buffer zero is started
  again, but at the next offset.
 *
 * Copyright 2013-2016 Gavin Stewart.
 *
 * You are required to give attribution to the author (Gavin Stewart) for any
 * use of this program (GPLv3 Section 7b).
 * 
 * Trying to pass off my code as your own in your Elements of Computing classes
 * will result in a cursed life of forever buggy software.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

class GASscroller {

    const int screenBaseAddr = 16384; // JK, make this accessible for change

    field Array scrollSet;       // Set of scroller ring buffers (each shifted).
    field int scrollNumBuffers;  // Number of ring buffers in scrollSet.    
    field int scrollStride;      // Width of a single row in scroller.
    field int scrollLen;         // Length of each scroll buffer.
    field int scrollHead;        // Head of scroller ring buffer.
    field int scrollTail;        // Last entry of scroller ring buffer.
    field int scrollBufferIndex; // Index of current buffer.
    field int scrollX;           // X screen position (in words).
    field int scrollY;           // Y screen position (in rows).
    
    field String scrollText;     // Text string to scroll.
    field int scrollTextPos;     // Position of next char in scrollText.
    
    field Array font;            // Bitmap array of fonts.
    field int fontHeight;        // Height of font glyphs in rows.
    field int fontLen;           // Length of fonts bitmap.
    
    field Array scrollSinus;     // Sinus table for scroller.
    field int scrollSinusLen;    // Length of scrollSinus.
    field int scrollSinusPos;    // Current start position in scrollSinus.
    field int scrollBlankHeight; // Additional vertical blanking needed.
    
      
    /**
     * Constructor.
     */
    constructor GASscroller new () {
        var int i;
        var Array buffer;
        var String footer;
             
        // Setup font. Initialises fontHeight variable.
        initFont();                      
    
        // Setup constants.
        footer = "Text scroller demo.   Gavin Stewart 2013.";
        // scrollText length must be a factor of 2 for 2bit scroller!
        scrollText = "This is the scroll text, it should be long and drag on for a while .... boring everyone to death! It was a dark and stormy night .... in a galaxy far, far away ..... are we there yet ?          ";
    
        scrollNumBuffers = 8;           // 16bit word / 2bit scroll res.
        scrollStride = 29;              // On-screen width + one.
        scrollY = 40;       
        scrollX = 2;
        scrollLen = scrollStride * fontHeight; 
        
        // Sanity checks.
        if (MathsToo.mod(scrollText.length(), 2) > 0) {
            // Output.moveCursor(0,0);
            // Output.printString("Scroll text _must_ be a factor of 2: ");
            // Output.printInt(scrollText.length());
            GFX.moveCursor(0,0);
            GFX.printString("Scroll text _must_ be a factor of 2: ");
            GFX.printInt(scrollText.length());
            Sys.halt();
        }
               
        // Allocate buffers.
        scrollSet=Array.new(scrollNumBuffers);
        while (i < scrollNumBuffers) {
            buffer = Array.new(scrollLen);
            scrollSet[i] = buffer;
            i = i + 1;
        }
        
        // Initialise variables.
        scrollTail = scrollStride - 1;
        
        // Init sinus.
        scrollBlankHeight = 3;
        initSinus(0, 15, 25);
        
        // Draw screen elements.
        // Screen.setColor(true);   // black
        // Screen.drawLine(32, 39, 479, 39);
        // Screen.drawLine(32, 71, 479, 71);
        // Screen.drawLine(31, 40, 31, 70);
        // Screen.drawLine(480, 40, 480, 70);
        GFX.setColor(true);   // black
        GFX.drawLine(32, 39, 479, 39);
        GFX.drawLine(32, 71, 479, 71);
        GFX.drawLine(31, 40, 31, 70);
        GFX.drawLine(480, 40, 480, 70);
        
        // Output.moveCursor(22, 10);
        // Output.printString(footer);
        GFX.moveCursor(22, 10);
        GFX.printString(footer);
        // GFX.printString( "hi" );
        GFX.moveCursor(0, 0);
               
        //MemoryToo.plotHoles();
        //Sys.halt();
        	          
        return this;
    }
    
    /**
     * Destructor.
     */
    method void dispose () {
        var int i;
        var Array a;
        
        while (i < scrollNumBuffers) {
            a = scrollSet[i];
            a.dispose();
        }
        scrollText.dispose();
        font.dispose();
        scrollSinus.dispose();
        
        // Memory.deAlloc(this);
        DataMemory.deAlloc(this);
        
        return;
    }

    method void initFont () {       
        var int y;
        var int c;
        var int j;
        var int RAM;
        
        // Allocate space for font bitmap.
        fontHeight = 10;                    // Could 9 if we ignored
                                                // lower case.
        fontLen = (127 - 32) * fontHeight;  // All defined chars.
        font = Array.new(fontLen);                  
        
        // Render character glyphs to screen and capture bitmaps.        
        y = 0;                          // Bitmap row.
        c = 32;                         // Current character.       
        while (c < 127) {                   // Chars 32 to 126
            // Output.moveCursor(0, 0);
            // Output.printChar(c);
            GFX.printChar(c);
	       	
            // RAM = 16384 + 32;           // Start of glyph on screen.    
            // RAM = screenBaseAddr + 32;           // Start of glyph on screen.    
	       	RAM = screenBaseAddr;           // Start of glyph on screen.    
	        j = 0;                      // Screen rows read back.
	        while (j < fontHeight) {

	            font[y] = RAM[0];       // Store word to font bitmap.
	            RAM += 32;         // Increment screen row.
	            j += 1;
	            y += 1;              // Increment bitmap row.
	        }
            c += 1;                  // Increment char.

            GFX.backSpace();  // JK
        }
        
        // Blank out last rendered character
        // Output.moveCursor(0, 0);
        // Output.printChar(32);            // Space
        // GFX.backSpace();
        
        // DEBUG: draw font bitmap to screen.
        /*
        // Screen.setColor(true);           // Black
        // Screen.drawRectangle(0, 0, 511, 255);
        RAM = 16384;
        c = 0;          // Font glyph row counter.
        j = 0;          // Screen row counter.
        y = 0;          // Font bitmap row counter.
        while ( y < fontLen ) {
            RAM[0] = font[y];
            RAM = RAM + 32;
            c = c + 1;
            j = j + 1;
            y = y + 1;
            if (c = fontHeight) {   // One line space between glyhps.
                RAM = RAM + 32;
                j = j + 1;
                c = 0;
            }
            if (MathsToo.mod(j, 256) = 0) { // Reached full screen height.
                RAM = 16384 + ((j / 256) * 2);  // Set to top of next col.
            }          
        }
        Sys.halt();
        */
        
        return;
    }
    
    /**
     * Initialise scroller sinus array.
     *
     * @param int min
     *  Minimum value in sinus table.
     * @param int max
     *  Maximum value in sinus table.
     * @param int steps
     *  Numnber of steps in sinus table.
     */     
    method void initSinus (int min, int max, int steps) {
        var int i;
        var int d, scale;
        
        Sinus.init();
        scrollSinusLen = steps;
        scrollSinus = Sinus.resample(0, 360, scrollSinusLen);
        
        d = max - min;
        scale = 200 / d;
        
        // Rescale our -100 to 100 sinus range to between min and max.
        // Must be carefull not to overflow 16bit signed int.
        while (i < scrollSinusLen) {
            scrollSinus[i] = min + ((scrollSinus[i] + 100) / scale);
            i = i + 1;
        }
        
        return;
    }
        
    /**
     * App run loop.
     */
    method void run () {
        var int i;
    
        // while (1 = 1) {
        while (true) {
            updateScroller();
            drawScroller();   
            Sys.wait(15);  
            
            // DEBUG: Check RAM contents after some cyles have passed.
            /*
            i = i + 1;
            if (i > 600) {
                MemoryToo.plotHoles();
                Sys.halt();
            } 
            */     
        }

        return;
    }
 
    /**
     * Render scroller to screen.
     */
    method void drawScroller () {
        var int i, j, width, pos, spos;
        var int RAM;
        var int colRAM, colBuffer;
        var Array buffer;
        
        width = scrollStride - 1;                // Last word is not shown.
        // RAM = 16384 + scrollX + (scrollY * 32); // x = 0, y = 40
        RAM = screenBaseAddr + scrollX + (scrollY * 32); // x = 0, y = 40
        buffer = scrollSet[scrollBufferIndex];   
             
        // Draw buffer to screen, row at a time.
        // This is the easiest way, but limits the rows to straight lines
        // (not sinus), and makes vsync tearing very visible.
        
        /*while (j < fontHeight) {

            pos = scrollHead;
            i = 0;          
            while (i < width) {

                RAM[i] = buffer[pos];

                pos += 1;
                if (pos = scrollStride) {

                    pos = 0;
                }

                i += 1;
            }
            buffer += scrollStride; // Increment buffer row.
            RAM += 32;                 // Increment screen row.
            j += 1;
        }*/
        
        
        // Draw buffer to screen, column at a time.   
        // More complicated, but we can place columns anywhere now (sinus),
        // no vsync tearing visible with this method.
        spos = scrollSinusPos;
        pos = scrollHead;
        colRAM = RAM;                           // Start screen column
        colBuffer = buffer;                     // Start buffer column
        
        while (i < width) {

            RAM = colRAM + i;                   // Screen x offset.
            RAM = RAM + (scrollSinus[spos]*32); // Screen y offset. Sinus.
            buffer = colBuffer + pos;           // Buffer x offset.

            j = 0;
            while (j < scrollBlankHeight) {         // Some vertical blanking.

                RAM[0] = 0;
                RAM += 32;
                j += 1;
            }

            j = 0;
            while (j < fontHeight) {                // Draw column from buffer.

                RAM[0] = buffer[0];
                buffer = buffer + scrollStride; // Increment buffer row.
                RAM = RAM + 32;                 // Increment screen row.
                j = j + 1;
            }

            j = 0;
            while (j < scrollBlankHeight) {         // Some vertical blanking.

                RAM[0] = 0;
                RAM += 32;
                j += 1;
            }

            spos += 1;                    // Inc sinus position.
            if (spos = scrollSinusLen) {

                spos = 0;
            }

            pos += 1;                      // Inc buffer position.
            if (pos = scrollStride) {

                pos = 0;
            }

            i += 1;
        }
        
        // Update starting offset into sinus, makes it look wiggly and not
        // static.
        scrollSinusPos += 1;
        if (scrollSinusPos == scrollSinusLen) {

            scrollSinusPos = 0;                     // Wrap index.
        }
              
        // Use next buffer next time.
        scrollBufferIndex += 1;
        if (scrollBufferIndex == scrollNumBuffers) { 

            scrollBufferIndex = 0;                  // Wrap index.
            
            // Increment tail and head indexes into buffers.
            scrollTail = scrollHead;
            scrollHead += 1;

            if (scrollHead == scrollStride) {

                scrollHead = 0;                     // Wrap index.
            }

            // Increment index into scroll text.
            scrollTextPos += 2;

            if (scrollTextPos == scrollText.length()) {

                scrollTextPos = 0;                  // Wrap index.
            }
        }
        
        return;
    }
    
    /**
     * Update a single scroller buffer before next draw. Only the last
     * two words in the buffer need be updated (for each row).
     */
    method void updateScroller () {
        var int i, j;
        var int charVal, charOffsetLow, charOffsetHigh;        
        var Array buffer, bufferPrev;
        var int tailPrev, tmp;

        //Sys.wait(500); 
        //Output.moveCursor(0,0);
        //Output.printInt(scrollBufferIndex);
        //Output.printString(";");
        
        // Note: Even though LSB to MSB is drawn right to left, the screen
        //       renders LSB to MSB left to right. Word operations here show 
        //       the low part followed by the high part to ease debugging on
        //       paper.
    
        if (scrollBufferIndex = 0) {    // Update 0 buffer directly from font.

            buffer = scrollSet[0];
            
            // Insert two chars into word (high and low bytes).
            charVal = scrollText.charAt(scrollTextPos);
            charOffsetLow = (charVal - 32) * fontHeight;    // First char.
            charVal = scrollText.charAt(scrollTextPos + 1);
            charOffsetHigh = (charVal - 32) * fontHeight;   // Second char.
            while (j < fontHeight) {

                // buffer[scrollTail] = (font[charOffsetHigh] * 256) | font[charOffsetLow];    // 00000000xxxxxxxx
                // buffer[scrollTail] = font[charOffsetLow] | ( font[charOffsetHigh] / 256 );  // xxxxxxxx00000000  JK, change to reflect pixel order
                buffer[scrollTail] = font[charOffsetLow] | ( font[charOffsetHigh] >> 8 );      // xxxxxxxx00000000  JK, change to reflect pixel order
                
                buffer += scrollStride;     // Increment buffer row.
                charOffsetLow += 1;  // Increment font row.
                charOffsetHigh += 1;
                j += 1;
            }
            
            return;
        } 
        
        // Update buffer from previous buffer.
        buffer = scrollSet[scrollBufferIndex];
        bufferPrev = scrollSet[scrollBufferIndex - 1];  // Ok, never < 0
        
        if (scrollTail > 0) {
            tailPrev = scrollTail - 1;
        } else {
            tailPrev = scrollStride - 1;
        }
        
        while (j < fontHeight) {        
            // 1bit steps.
            // buffer[tailPrev] = MathsToo.lsr(bufferPrev[tailPrev], 1) | MathsToo.lsl(bufferPrev[scrollTail], 15);
            // buffer[scrollTail] = bufferPrev[scrollTail] / 2;
        
            // 2bit steps.            
            // buffer[tailPrev] = MathsToo.lsr(bufferPrev[tailPrev], 2) | (bufferPrev[scrollTail] * 16384);
            // buffer[scrollTail] = bufferPrev[scrollTail] / 4;
            // buffer[tailPrev] = ( bufferPrev[tailPrev] >> 2 ) | ( bufferPrev[scrollTail] << 14 );
            // buffer[scrollTail] = bufferPrev[scrollTail] >> 2;
            buffer[tailPrev] = ( bufferPrev[tailPrev] << 2 ) | ( bufferPrev[scrollTail] >> 14 );  // JK, change to reflect pixel order
            buffer[scrollTail] = bufferPrev[scrollTail] << 2;                                     // JK, change to reflect pixel order

            // Optimised 2bit steps via awkward logical shift right by 2 bits.
            /*
            tmp = bufferPrev[tailPrev];
            if (tmp < 0) {
                // MSB == 1, which makes number negative, so we strip sign bit,
                // then normal division, then put back bit we stripped
                // shifted right by 2 bits. Using built in division is faster
                // than a function call, and faster than a sequence of if(mask)
                // statements.
                tmp = tmp & 32767;   // 0111 1111 1111 1111
                tmp = tmp / 4;
                tmp = tmp | 8192;    // 0010 0000 0000 0000
            } else {
                tmp = tmp / 4;
            }           
            // buffer[tailPrev] = tmp | (bufferPrev[scrollTail] * 16384);  
            buffer[tailPrev] = tmp | (bufferPrev[scrollTail] * screenBaseAddr);  
            // Note: We get away with ASR bellow only because the value is
            // never negative (due to glyph always having a one pixel border
            // on that bit). Otherwise this would also need to be done with
            // LSR.
            buffer[scrollTail] = bufferPrev[scrollTail] / 4;*/
    
            // 4bit steps.
            //buffer[tailPrev] = MathsToo.lsr(bufferPrev[tailPrev], 4) | (bufferPrev[scrollTail] * 4096);
            //buffer[scrollTail] = bufferPrev[scrollTail] / 16;
                      
            // Move onto next row.
            buffer += scrollStride;      // Inc buffer row.
            bufferPrev += scrollStride;  // Inc bufferPrev row.
            j += 1;
        }

        return;
    }   
  
}
